---
title: Common Mismatches
description: Causes, diagnosis, and fixes for React hydration mismatch errors including dates, locales, invalid HTML nesting, browser extensions, and non-deterministic rendering
tags:
  [
    hydration,
    mismatch,
    dates,
    locale,
    html-nesting,
    browser-extensions,
    suppressHydrationWarning,
  ]
---

# Common Mismatches

Hydration mismatches occur when the HTML generated by the server does not match what React expects during client-side hydration. React recovers from some mismatches by re-rendering, but this destroys performance and can attach event handlers to wrong elements.

## Non-Deterministic Values

The most common hydration trap. Server renders at time T1, client hydrates at time T2 with different values.

### Date and Time

```tsx
// WRONG: Different output on server vs client
function Timestamp() {
  return <span>{new Date().toLocaleTimeString()}</span>;
}

// CORRECT: Two-pass rendering for client-only time display
function Timestamp() {
  const [time, setTime] = useState<string | null>(null);

  useEffect(() => {
    setTime(new Date().toLocaleTimeString());
  }, []);

  if (!time) return <span>Loading...</span>;
  return <span>{time}</span>;
}
```

### Random Values

```tsx
// WRONG: Different random value on server vs client
function RandomGreeting() {
  const greetings = ['Hello', 'Hi', 'Hey'];
  return <span>{greetings[Math.floor(Math.random() * 3)]}</span>;
}

// CORRECT: Use a stable seed from server or useId for determinism
import { useId } from 'react';

function RandomGreeting() {
  const id = useId();
  const greetings = ['Hello', 'Hi', 'Hey'];
  const index = Math.abs(hashString(id)) % greetings.length;
  return <span>{greetings[index]}</span>;
}
```

## Locale and Formatting Differences

Server and client may use different locales, causing formatting mismatches in numbers, currencies, and dates.

```tsx
// WRONG: Browser locale may differ from server locale
function Price({ amount }: { amount: number }) {
  return (
    <span>
      {amount.toLocaleString(undefined, { style: 'currency', currency: 'USD' })}
    </span>
  );
}

// CORRECT: Pass explicit locale from server context
function Price({ amount, locale }: { amount: number; locale: string }) {
  return (
    <span>
      {amount.toLocaleString(locale, { style: 'currency', currency: 'USD' })}
    </span>
  );
}
```

For relative timestamps like "2 minutes ago", render a static format on the server and update to relative format on the client via `useEffect`.

## Invalid HTML Nesting

Browsers auto-correct invalid HTML, causing the DOM to differ from what React expects.

```tsx
// WRONG: <p> cannot contain block elements; browser removes inner <p>
function Article() {
  return (
    <p>
      Intro text
      <p>Nested paragraph</p>
    </p>
  );
}

// CORRECT: Use appropriate nesting
function Article() {
  return (
    <div>
      <p>Intro text</p>
      <p>Nested paragraph</p>
    </div>
  );
}
```

**Common invalid nesting that causes hydration errors:**

| Invalid                     | Why                                 | Fix                                |
| --------------------------- | ----------------------------------- | ---------------------------------- |
| `<p>` inside `<p>`          | `<p>` cannot contain block elements | Use `<div>` or `<span>`            |
| `<div>` inside `<p>`        | Block inside inline                 | Restructure with `<div>` as parent |
| `<a>` inside `<a>`          | Interactive inside interactive      | Restructure; use separate links    |
| `<table>` without `<tbody>` | Browser auto-inserts `<tbody>`      | Explicitly include `<tbody>`       |

## Browser Extensions

Extensions like Dark Reader, Google Translate, and password managers inject or modify DOM elements, causing mismatches between what React rendered on the server and what it finds in the browser.

**Common extension-induced issues:**

- Translation extensions wrap text nodes in `<font>` or `<span>` tags
- Dark Reader injects `<style>` elements and modifies inline styles
- Ad blockers remove or hide DOM elements
- Password managers inject input overlays

**Mitigation strategies:**

```tsx
// Use suppressHydrationWarning on elements commonly modified by extensions
<html suppressHydrationWarning>
  <body suppressHydrationWarning>
    <App />
  </body>
</html>
```

For content areas specifically targeted by translation extensions, consider wrapping with `translate="no"` to prevent translation-induced mismatches:

```tsx
<span translate="no">{criticalText}</span>
```

## The typeof window Check

A frequent mistake is checking `typeof window !== 'undefined'` directly in the render path.

```tsx
// WRONG: This check runs on both server (false) and client (true),
// producing different output and causing a hydration mismatch
function Navigation() {
  if (typeof window !== 'undefined') {
    return <ClientNav />;
  }
  return <ServerNav />;
}

// CORRECT: Two-pass rendering
function Navigation() {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  return isClient ? <ClientNav /> : <ServerNav />;
}
```

## suppressHydrationWarning

React provides `suppressHydrationWarning` as an escape hatch for unavoidable single-element mismatches. It only works one level deep and does NOT patch mismatched content.

```tsx
// Acceptable: leaf element with unavoidable time difference
<time suppressHydrationWarning dateTime={date.toISOString()}>
  {date.toLocaleTimeString()}
</time>

// WRONG: suppressing on containers hides real bugs
<div suppressHydrationWarning>
  <ComplexComponent />
</div>
```

**Rules for suppressHydrationWarning:**

- Use only on leaf text elements (not containers)
- The mismatch must be genuinely unavoidable (timestamps, UUIDs)
- React will NOT patch the content; the server value persists until a re-render
- Never use it to silence bugs; fix the root cause instead

## Debugging Hydration Errors

1. **Read the error message** -- React provides a diff showing expected vs actual content
2. **Check for non-deterministic code** in the render path (`Date`, `Math.random`, browser APIs)
3. **Validate HTML nesting** -- use the W3C validator or browser DevTools
4. **Disable browser extensions** to isolate extension-caused mismatches
5. **Compare server HTML** with client DOM using `view-source:` vs DevTools Elements panel
6. **Check `onRecoverableError`** logs for silent recovery events (see validation-techniques reference)
