---
title: Virtual File Routes
description: Programmatic route configuration with rootRoute, route, index, layout, and physical builders for mixing file-based and code-based routing
tags:
  [
    virtual-routes,
    rootRoute,
    route,
    index,
    layout,
    physical,
    code-based-routing,
  ]
---

# Virtual File Routes (v1.140+)

Programmatic route configuration when file-based conventions don't fit. Virtual file routes let you define the route tree in code while keeping route implementations in separate files.

## When to Use

- Route structure doesn't map cleanly to filesystem hierarchy
- Need routes from multiple directories
- Want explicit control over route nesting
- Need to mix file-based subtrees with code-defined routes

## Setup

Configure in `tsr.config.json` or the Vite plugin:

```ts
TanStackRouterVite({
  virtualRouteConfig: './src/routes.ts',
});
```

Or inline in the Vite plugin:

```ts
import {
  rootRoute,
  route,
  index,
  layout,
  physical,
} from '@tanstack/virtual-file-routes';

TanStackRouterVite({
  virtualRouteConfig: rootRoute('root.tsx', [
    index('home.tsx'),
    route('/about', 'about.tsx'),
  ]),
});
```

## Builders

### rootRoute(file, children)

Defines the root route. All other routes nest inside:

```ts
import { rootRoute } from '@tanstack/virtual-file-routes';

export const routes = rootRoute('root.tsx', [
  // children here
]);
```

The file path (`root.tsx`) is relative to the routes directory.

### index(file)

Defines an index route (renders at the parent's exact path):

```ts
rootRoute('root.tsx', [
  index('home.tsx'), // renders at '/'
]);
```

### route(path, file, children?)

Defines a route with an explicit URL path:

```ts
rootRoute('root.tsx', [
  route('/posts', 'posts/layout.tsx', [
    index('posts/list.tsx'),
    route('$postId', 'posts/detail.tsx'),
    route('$postId/edit', 'posts/edit.tsx'),
  ]),
  route('/about', 'about.tsx'),
]);
```

Dynamic segments use `$` prefix, same as file-based routing.

### layout(id, file, children)

Defines a pathless layout route (wraps children without adding a URL segment):

```ts
rootRoute('root.tsx', [
  layout('authenticated', 'layouts/auth-layout.tsx', [
    route('/dashboard', 'dashboard.tsx'),
    route('/settings', 'settings.tsx'),
  ]),
  layout('public', 'layouts/public-layout.tsx', [
    route('/login', 'login.tsx'),
    route('/register', 'register.tsx'),
  ]),
]);
```

The `id` parameter uniquely identifies the layout (used in generated route IDs).

### physical(path, directory)

Delegates a subtree to file-based routing conventions:

```ts
rootRoute('root.tsx', [
  index('home.tsx'),
  route('/about', 'about.tsx'),
  physical('/docs', 'docs'),
]);
```

The `docs` directory uses standard file-based routing conventions. This lets you mix approaches within a single app.

## Full Example

```ts
import {
  rootRoute,
  route,
  index,
  layout,
  physical,
} from '@tanstack/virtual-file-routes';

export const routes = rootRoute('root.tsx', [
  index('home.tsx'),

  layout('marketing', 'layouts/marketing.tsx', [
    route('/features', 'marketing/features.tsx'),
    route('/pricing', 'marketing/pricing.tsx'),
  ]),

  layout('app', 'layouts/app.tsx', [
    route('/dashboard', 'app/dashboard.tsx', [
      index('app/dashboard-home.tsx'),
      route('analytics', 'app/analytics.tsx'),
      route('settings', 'app/settings.tsx'),
    ]),
    route('/projects', 'app/projects.tsx', [
      index('app/projects-list.tsx'),
      route('$projectId', 'app/project-detail.tsx'),
    ]),
  ]),

  physical('/blog', 'blog'),
]);
```

Corresponding file structure:

```sh
src/routes/
├── root.tsx
├── home.tsx
├── layouts/
│   ├── marketing.tsx
│   └── app.tsx
├── marketing/
│   ├── features.tsx
│   └── pricing.tsx
├── app/
│   ├── dashboard.tsx
│   ├── dashboard-home.tsx
│   ├── analytics.tsx
│   ├── settings.tsx
│   ├── projects.tsx
│   ├── projects-list.tsx
│   └── project-detail.tsx
└── blog/
    ├── index.tsx          # file-based: /blog
    ├── $slug.tsx          # file-based: /blog/$slug
    └── categories.tsx     # file-based: /blog/categories
```

## Route File Implementation

Route files for virtual routes use `createFileRoute` with the generated path:

```ts
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/dashboard')({
  component: DashboardPage,
  loader: async ({ context }) =>
    context.queryClient.ensureQueryData(dashboardQueries.stats()),
});

function DashboardPage() {
  const data = Route.useLoaderData();
  return <div>{data.stats.totalUsers} users</div>;
}
```

The route path string in `createFileRoute` is auto-generated by the plugin.

## Code Splitting with Virtual Routes

Use `autoCodeSplitting` instead of manual `.lazy.tsx` files:

```ts
TanStackRouterVite({
  autoCodeSplitting: true,
  virtualRouteConfig: './src/routes.ts',
});
```

Manual `createLazyFileRoute` is silently replaced in virtual route mode. Always use `autoCodeSplitting` instead (see Known Issues #18).

## Index and Layout Conflict

When using `physical()`, avoid placing both `route.tsx` and `index.tsx` in the same directory. Use a pathless layout instead:

```sh
# Problem: route.tsx and index.tsx conflict
docs/
├── route.tsx    # layout for /docs
└── index.tsx    # index for /docs — CONFLICT

# Solution: pathless layout
docs/
├── _layout.tsx        # pathless layout wrapper
├── _layout.index.tsx  # index for /docs
└── $slug.tsx          # /docs/$slug
```

See Known Issues #6 for details.

## Config File Approach

For larger apps, export the config from a separate file:

```ts
import { rootRoute, route, index, layout } from '@tanstack/virtual-file-routes';

export const routes = rootRoute('root.tsx', [
  index('home.tsx'),
  route('/about', 'about.tsx'),
]);
```

Reference it in `tsr.config.json`:

```json
{
  "virtualRouteConfig": "./src/routes.ts"
}
```
